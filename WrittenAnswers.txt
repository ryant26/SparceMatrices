1.) What is a sparce matrix?
	A matrix in which most of the elements are 0.
	A matrix is often considered sparse if there are enough 0 entries to be worth taking advantage of them to optimize storage and algorithm runtime costs.
	
	- Compressed Row Storage
	- Compressed Sparse Column
	- Dictionary of keys
	- Coordinate list
	- etc

2.) Wikeipedia - http://en.wikipedia.org/wiki/Sparse_matrix
	Iterative Methods For Sparse Linear Systems -http://www-users.cs.umn.edu/~saad/IterMethBook_2ndEd.pdf

	Sparse matrices are abstract and mathematical, so meatspace analogies are (ahem) sparse at best.
	Conventional matrices are analogous, though, and are useful for API examples.
	

3.) Sparse matricies are often used to solve partial differential equations (PDE) which arrise in all fields of engineering. PDE's model: 
	- sound 
	- heat
	- electrostatics
	- fluid flow
	- vibration 
	and more!

	They are important in computer graphics to model:
	- physical deformation
	- mesh smoothing
	- diffusion equations for terrain generation
	
	Common matrix transformations and operations are desireable by library users.
	It is assumed that row- and column-wise operations are less desireable than they would be for a conventional (non-sparse) matrix library.
	So, features to find sums, averages, maxes and mins of matrix axes, columns, or rows are omitted in favor of operations on the entire matrix.
	For instance computing eigenvalues of these systems is often desired and to do so would require obtaining the determinant.
	We would want to be able to compute the product of 2 sparse matrices.
	Addition and subtraction.
	
	Operations:
	- addition
	- subtraction
	- product
	- determinant
	- eigenvalues
	
	Transformations:
	- inverse
	- transpose
	- resize
	
	Tests:
	- isDiagonal
	- isTriDiagonal
	- isIdentity
	- isZero
	- isInvertible
	
	Our users may desire complex-valued matrix elements.
	So, if necessary, project scope may be increased by supporting complex matrices and relevant operations:
	- complex conjugate
	- conjugate transpose
	- isHermitian
	- etc
	


Other Notes:
============
- I think we should use a hashtable as our data store, satisfying the O(p) complexity for the insertion of the m+1 element
	-Keys will be [Row, Colum] (Or another dimensional index) [a,b,c, ... ,n]
		-If that value is non-zero it will exist in the hashtable
		-If that value is zero it will not exist in the hashtable

- This also means the memory usage will satisfy O(km) where k << N

- I'm not sure how the hashing algorithm works in Ruby, it's possible that the insertion / retrieval algorithm complexity would increase a lot if we had a HUGE matrix. 
  Millions by Millions or something.
